#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble

\usepackage[cm]{fullpage}\usepackage{acronym}

%opening
\title{}
\author{}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing double
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=black,citecolor=black,filecolor=black,urlcolor=black"
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 40mm
\topmargin 25mm
\rightmargin 10mm
\bottommargin 25mm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Abstract

\lang british
TODO : Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Abstract

\lang british
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section

\lang british
Introduction
\end_layout

\begin_layout Section

\lang british
Literature Review
\end_layout

\begin_layout Section

\lang british
Computational Methods
\end_layout

\begin_layout Subsection

\lang british
Potential Field Force Navigation
\begin_inset CommandInset label
LatexCommand label
name "sub:Potential-Field-Force"

\end_inset


\end_layout

\begin_layout Standard

\lang british
For this project, it was decided that a potential field force navigation
 technique would be used to control the individual (as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "intelligentAlgorithmPathPlanning"

\end_inset

.
 The field is produced by taking a collection of objects and projecting
 a field around them of a given shape.
 This field can either add to or subtract from the total field potential
 surrounding it.
 The total field can then be calculated with equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fieldSummation"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
P(x,y)=\sum_{i=0}^{N-1}p_{i}\left(x,y\right)\label{eq:fieldSummation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing double
\noindent

\lang british
Where:
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula $P\left(x,y\right)$
\end_inset

 is the total field potential at point 
\begin_inset Formula $\left(x,y\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula $p_{i}\left(x,y\right)$
\end_inset

 is the potential produced by object 
\begin_inset Formula $i$
\end_inset

 at a point.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula $N$
\end_inset

 is the number of field producing objects.
\end_layout

\begin_layout Standard

\lang british
The direction that the robot will move in is then determined by the gradient
 of the field at the current point, such that the robot moves down the field
 potential.
 The force vector (which controls the velocity of the robot) is given by
 equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:forceSummation"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
\boldsymbol{F}(x,y)=-\left(\frac{{\partial P\left(x,y\right)}}{\partial x}+\frac{{\partial P\left(x,y\right)}}{\partial y}j\right)\label{eq:forceSummation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
If the fields can be differentiated over the entire field, this can be calculate
d as in equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:forceDifferentiation"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
\boldsymbol{F}(x,y)=-\left(\sum_{i=0}^{N-1}\frac{\partial p_{i}\left(x,y\right)}{\partial x}+\frac{\partial p_{i}\left(x,y\right)}{\partial y}j\right)\label{eq:forceDifferentiation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
However, if one or more of the fields cannot be differentiated, the force
 vector must be calculated discretely.
 This is achieved using equation .
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
\boldsymbol{F}(x,y)=\left(P\left(x-1,y\right)-P\left(x+1,y\right)\right)+\left(P\left(x,y-1\right)-P\left(x,y+1\right)\right)j
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
The negative gradient is used to ensure the robot moves towards lower field
 potentials.
 The technique would work equally well if it was attracted to higher field
 potentials, provided all the equations were suitably inverted.
 
\end_layout

\begin_layout Standard

\lang british
For the initial control technique, the velocity of the robot is proportional
 to the force vector.
 Other techniques are discussed by 
\begin_inset CommandInset citation
LatexCommand cite
key "intelligentAlgorithmPathPlanning"

\end_inset

, but will be experimented on later.
 
\end_layout

\begin_layout Standard

\lang british
Navigation of the game field can now be achieved by manipulating the attractive
 and repulsive fields to guide the robot to a target.
 Computational power allowing, each robot would have a separate field that
 guides it based on the goals specific to its role.
 
\end_layout

\begin_layout Subsection

\lang british
Potential Field Shapes
\end_layout

\begin_layout Standard

\lang british
Attractive fields are used to designate areas which the robot should be
 headed for.
 In order to ensure that the robot always heads towards them, it is important
 that their effect is felt across the entire field.
 However, they must not be so strong that they overwhelm the short distance
 effects of the repulsive fields, but strong enough to govern the robot's
 overall destination.
\end_layout

\begin_layout Standard

\lang british
Repulsive fields are used to alter the route of the robot when heading for
 these targets.
 For example, such fields are used to get the robot to avoid collisions,
 as well as to control where the robot intercepts the ball.
 These fields typically only act over a short distance, as they should only
 have an effect when they are required.
 They need to be strong enough to overwhelm the attractive fields at short
 range.
\end_layout

\begin_layout Standard

\lang british
The field shapes experimented with are described in the following sections,
 in order to determine the best combination for each scenario.
 As the basic fields in use are axisymmetric in shape (or begin that way),
 the fields are best described using polar coordinates.
 The coordinates are defined as in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:polarCoordinateFrame"

\end_inset

, and are always centred on the field producing object.
 This frame of reference can then be translated to the Cartesian coordinates
 in use elsewhere to allow the total field at a point to be calculated.
\end_layout

\begin_layout Subsubsection

\lang british
Basic Attractive Field
\begin_inset CommandInset label
LatexCommand label
name "sub:Basic-Attractive-Field"

\end_inset


\end_layout

\begin_layout Standard

\lang british
The field suggested by 
\begin_inset CommandInset citation
LatexCommand cite
key "intelligentAlgorithmPathPlanning"

\end_inset

 for the attractive point is described with equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:quadraticBallField"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
P(r,\theta)=\frac{1}{2}k_{attr}r^{2}\label{eq:quadraticBallField}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
Where 
\begin_inset Formula $k_{attr}$
\end_inset

 is the attractive weight assigned to the ball.
\end_layout

\begin_layout Standard

\lang british
This produces an attractive force that is linearly proportional to the distance
 to the object (in this case the ball).
 This is a very useful field for a route finder (as described in the paper),
 where it is desirable for the the robot to stop when it reaches the destination
, and so it needs to slow down as it approaches the target.
 However, in this application it is more useful for the robot to make a
 rapid approach and not slow down after arrival, as this will hit the ball
 away from the robot.
 
\end_layout

\begin_layout Standard

\lang british
In order to overcome this problem, the field was simplified to equation
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:conicBallField"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
P(r,\theta)=\frac{1}{2}k_{attr}r\label{eq:conicBallField}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
This field produces a constant force of 
\begin_inset Formula $k_{attr}$
\end_inset

 acting towards the centre of the ball, which will hold the robot against
 the ball (as far as possible) as the ball and robot move around.
 It doesn't provide any guidance once the ball has been reached, and so
 this will need to be provided by an additional field once the intercept
 is complete.
\end_layout

\begin_layout Subsubsection

\lang british
Basic Repulsive Field
\begin_inset CommandInset label
LatexCommand label
name "sub:Basic-Repulsive-Field"

\end_inset


\end_layout

\begin_layout Standard

\lang british
One of the rules of the game is that the robot cannot intentionally collide
 with an opposing robot, unless they are in possession of the ball 
\begin_inset CommandInset citation
LatexCommand cite
key "simurosotSim"

\end_inset

.
 This means that the robot must actively avoid the other robots.
 It is also advantageous to be able to avoid the robots own team, as this
 prevents the robots getting into a position where they cannot move as they
 are fighting against each other.
\end_layout

\begin_layout Standard

\lang british
A apparently simple solution would be to surround all the obstacles with
 a region of potential that is substantially higher than the surrounding
 area, as described by equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:circleRepulseField"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
P\left(r,\theta\right)=\begin{cases}
k_{repulse} & r<R_{0}\\
0 & r\geq R_{0}
\end{cases}\label{eq:circleRepulseField}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
Where 
\begin_inset Formula $k_{repulse}$
\end_inset

is the repulsive potential and 
\begin_inset Formula $R_{0}$
\end_inset

is the radius of the circle.
 This produces a field as illustrated in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:circleField"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
In theory, the robot would avoid this circle, as the algorithm should not
 have the robot move into a region of high potential.
 However, this does not work, as the controller actually responds to the
 gradient of the field (shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:circleFieldGradient"

\end_inset

).
 As shown in the figure, this type of field produces very high force, but
 only in a very small region.
 Once inside the repulsive circle, the gradient returns again to zero, and
 so does not effect the motion of the robot.
 As the robot has inertia, it is very likely that it pass through the region
 of high force and then leave it before it's velocity has altered sufficiently
 to avoid the obstacle.
\end_layout

\begin_layout Standard

\lang british
In order to maximise the repulsive effect of the field, the force must be
 exerted over a large area.
 This can be achieved with a field that gradually builds in strength as
 it nears the obstacle.
 The simplest example is defined by equation .
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\[
P\left(r,\theta\right)=\begin{cases}
k_{repulse}\cdot r & r<R_{0}\\
0 & r\geq R_{0}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard

\lang british
This field will create a constant force that acts radially away from the
 obstacle, much like the attractive force described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Basic-Attractive-Field"

\end_inset

, but over a restricted area (as illustrated in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:conicRepelField"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ConicRepelFieldGradient"

\end_inset

).
 If the target is behind the obstacle, and the force is exactly strong enough,
 it will cause the robot to stop in the repulsive field.
 If the force is too small, it will only slow the robot down, and if the
 force is too strong it will cause the robot to move clear of the field.
 If the target hasn't moved significantly, the robot will then approach
 the repulsive field again, only to be repelled once more.
 This will result in the robot repeatedly 'bouncing' off of the field.
 The robot will become stuck if the target does not move, but it is thought
 that the rapidly changing environment the controller will be working in
 will mean that this is not a significant issue.
\end_layout

\begin_layout Standard

\lang british
While the constant force will work, provided it is strong enough, the case
 when it is too strong and causes 'bouncing' is undesirable as the motion
 of the robot will become erratic.
 A better solution would be one where the force gradually increases as it
 approaches the target.
 It is also desirable to have a field that naturally decays to a small level
 at a distance without relying on conditional operations.
 Two field shapes which meet this specification are a direct inverse proportiona
lity, or the Gaussian function (described by equations 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:inverseRepulseField"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:gaussianRepulseField"

\end_inset

 respectively).
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
P\left(r,\theta\right)=\frac{k_{repulse}}{r}\label{eq:inverseRepulseField}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
P\left(r,\theta\right)=k_{repulse}\cdot e^{\left(\frac{r^{2}}{2\sigma_{repulse}}\right)}\label{eq:gaussianRepulseField}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
Where 
\begin_inset Formula $\sigma_{repulse}$
\end_inset

 controls the width of the field.
\end_layout

\begin_layout Standard

\lang british
For this purpose, the Gaussian function was selected, because it was initially
 believed that a flatter region in the centre of the field would be preferable
 over an infinite field potential (see section TODO).
 This produces a field as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gaussianField"

\end_inset

.
 As the gradient image shows, this produces a region of rapidly increasing
 force around the object, with no discontinuities that produce disruptive
 motion at the edge of the field.
\end_layout

\begin_layout Subsubsection

\lang british
Shaped Approach Guiding Field
\begin_inset CommandInset label
LatexCommand label
name "sub:Shaped-Approach-Guiding"

\end_inset


\end_layout

\begin_layout Standard

\lang british
As the robot has no means of holding on to the ball, it is not possible
 for the robots to turn more than a small amount when in possession of the
 ball without losing it.
 This makes it particularly important that the robot approaches the ball
 from the correct side.
 This can be achieved by positioning a region around the ball that guides
 the robot to the correct position.
\end_layout

\begin_layout Standard

\lang british
The initial attempt at this placed a specially shaped field around the ball,
 which was developed by rotating a Gaussian function along a circle around
 the ball, with it's height proportional to the angle from the desired access
 direction.
 This is described by the equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:wrappedGaussian"

\end_inset

 and shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:wrappedGaussianField"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
P\left(r,\theta\right)=e^{\frac{-\left(r-r_{0}\right)^{2}}{2\sigma_{repulse}}}\cdot\left|\frac{\theta}{\pi}\right|\label{eq:wrappedGaussian}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\[
-\pi\leq\theta\leq\pi
\]

\end_inset


\end_layout

\begin_layout Standard

\lang british
This field initially looked promising, as it contains the desired slope
 towards a specific approach angle and repels away from every other angle.
 On testing, however, it was noticed that, because the field is at a higher
 potential than it's surroundings, the edges of the field force the robot
 radially away from the ball instead of towards the target angle, and so
 the robot just stops at the edge of the field.
\end_layout

\begin_layout Standard

\lang british
The field was then modified to be at a lower potential than it's surroundings,
 as shown in equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:insetWrappedGaussian"

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Formula 
\begin{equation}
P\left(r,\theta\right)=e^{\frac{-\left(r-r_{0}\right)^{2}}{2\sigma_{repulse}}}\cdot\left|\frac{\pi-\theta}{\pi}\right|\label{eq:insetWrappedGaussian}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\lang british
This removed the previous radial force.
 However, it was determined that a field wide enough to be of any use in
 directing the robot had to have a radius that caused the field to strongly
 interfere with motion elsewhere in the playing field.
 When other robots were introduced into the field, even in their starting
 positions, the robot was unable to approach the ball without a collision
 with another player.
\end_layout

\begin_layout Standard

\lang british
Other attempts were made with different shaped fields around the ball (for
 example one field resembled a helter-skelter slide, which produced a constant
 force to guide the ball in when within a certain radial region), but all
 resulted in either an large field that caused too much long-distance interferen
ce, or forced the robot radially away from the robot.
 While a field could probably be found that achieved what was desired, it
 was determined that the search would be too time-consuming with the lack
 of guiding information.
\end_layout

\begin_layout Subsubsection

\lang british
Paired Source Approach Guidance Field
\end_layout

\begin_layout Standard

\lang british
As discussed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Shaped-Approach-Guiding"

\end_inset

, a field was required to guide robot's the approach to ball.
 As a single field did not function as desired, it was decided that a pair
 of fields would be used.
\end_layout

\begin_layout Standard

\lang british
A basic attractive field (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Basic-Attractive-Field"

\end_inset

) was positioned on the desired approach side of the ball (offset by a number
 of inches in the 
\begin_inset Formula $x$
\end_inset

 axis) and a basic repulsive field (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Basic-Repulsive-Field"

\end_inset

) was placed in the symmetrically opposite position.
 This produces the overall field shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pairedApproachField"

\end_inset

.
 
\end_layout

\begin_layout Standard

\lang british
This technique immediatly showed positive results, with the robot moving
 onto the attractive point while avoiding the ball if it approached from
 the wrong side.
 This is achieved because the repulsive field forces the robot away from
 any approach vectors which would pass too close to the ball when the robot
 is on the opposite side, and the moved attraction point prevents the robot
 from colliding with the ball from the side
\end_layout

\begin_layout Standard

\lang british
TODO : Discuss modifying the field to place the sources in the line of motion
 instead of the along the x-axis.
\end_layout

\begin_layout Standard

\lang british
TODO : Discuss any other modifications to the process.
\end_layout

\begin_layout Standard

\lang british
TODO : Consider including a video showing this in action, or perhaps include
 it in the results section.
\end_layout

\begin_layout Standard

\lang british
When this field is in use, the robot is not attracted to the actual position
 of the ball, and so this field will not allow the robot to guide it to
 the goal.
 However, if a new set of field configurations are used once this robot
 is in position, this limitation can be overcome.
\end_layout

\begin_layout Subsection

\lang british
Field Calculations
\end_layout

\begin_layout Standard

\lang british
TODO : use acronym package
\end_layout

\begin_layout Standard

\lang british
TODO : use siunitx package
\end_layout

\begin_layout Standard

\lang british
In order to determine the direction the robot should move in, the field
 needs to be calculated at four points, as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Potential-Field-Force"

\end_inset

.
 Even for the most complex fields in use, this is not particularly computational
ly challenging.
 However, the efficiency of the code could be improved by vectorising the
 data and taking advantage of the Single Instruction Multiple Data (SIMD)
 instructions available on most modern CPUs to calculate all four points
 simultaneously.
 This would allow the field calculations to take less time, resulting in
 more time available per time-step to perform other operations.
\end_layout

\begin_layout Standard

\lang british
In addition, it is useful to render the entire field as an image, so that
 it can be considered for immediate debugging purposes.
 Given that the playing field is approximately 88 inches by 72 inches, and
 is being considered at 
\begin_inset Formula $\frac{1}{10}$
\end_inset

inch scale, this gives 633,600 data points to consider.
 This size of dataset will require a large amount of CPU cycles to calculate,
 even if the individual data point's requirements are relatively modest.
 With further delays introduced by inter-process communication (it is not
 possible to alter the simulator to produce the image locally), as well
 as other delays and overheads introduced by the operating system, it quickly
 becomes challenging to render the field in real-time.
\end_layout

\begin_layout Standard

\lang british
The calculation times for both the entire field and a set of four points
 using the OpenCl code on both the CPU and GPU are shown in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Field-Strenth-Calculation"

\end_inset

.
 These clearly show that the calculation of the entire field is best done
 on the GPU, where the acceleration from the massively parallel computation
 structure masks the additional overheads.
 The four points, however, are best done on the CPU, where it does not suffer
 from the significantly larger memory transfer times which affect GPU operations.
\end_layout

\begin_layout Standard

\lang british
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\lang british
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
Task
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
Computation Platform
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
Execution Time (us)
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
Memory Transfer Time (us)
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
Total Time (us)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
Entire field
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
CPU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
23500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
479
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
24100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
GPU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
2050
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
2600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
8611
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
Four data points
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
CPU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
14.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
0.342
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
60.0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
GPU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
18.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
1040
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang british
4390
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
In this test, overheads include transfering the inital data to the platform
 and setting up the platform before the calculation, but not one-time-only
 intialisation done by the platform.
\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset Caption

\begin_layout Plain Layout
Field Strenth Calculation Times
\begin_inset CommandInset label
LatexCommand label
name "tab:Field-Strenth-Calculation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\lang british
Design Philosophy
\end_layout

\begin_layout Standard

\lang british
The code (shown in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:OpenCL-Kernels"

\end_inset

) is written in an attempt to take advantage of the parallel nature of it's
 execution.
 Each kernel (a high-level function run either on the CPU or GPU) is designed
 to work on an individual data point, and then the kernel is called multiple
 times by the platform, once for each data point.
 As the order of execution cannot be guaranteed, each kernel is written
 such that it doesn't depend on the values produced for other data points.
\end_layout

\begin_layout Standard

\lang british
To simplify the code, the platform is configured to run the kernel over
 a 2D space that represents the field.
 Each instance of the kernel is then given an ID in each dimension by the
 computation platform, which is used to determine the coordinates of the
 data point it should be working on.
 This means that each instance can operate in isolation without any knowledge
 of what work has already been done.
 The results are then stored in a shared array (at an index determine by
 the coordinates) which is returned to the host program when the operation
 has finished.
 Where consecutive functions are required, a series of kernels are queued
 in turn, and the memory is only returned when the queue is complete (which
 represents a significant saving with the GPU code, as GPU to host transfers
 are relatively computationally expensive).
\end_layout

\begin_layout Standard

\lang british
For the first scenario, where only a limited number of points are required,
 the code is executed on the CPU in parallel, as the advantages of using
 the more powerful GPU are lost in the initial set-up delays which are not
 incurred when working on the CPU.
 The GPU is then used when the entire field is desired, when the accelerated
 calculations justify the set-up costs (see TODO RESULTS for exact calculations).
\end_layout

\begin_layout Subsubsection

\lang british
GPU Optimisations
\end_layout

\begin_layout Standard

\lang british
The architecture of a GPU presents different optimisation challenges to
 that of CPU.
 In particular, the number of concurrent operations the GPU can process
 is limited by the resource usage of the code.
\end_layout

\begin_layout Standard

\lang british
In order to calculate the Gaussian function, a function to calculate a power
 of 
\begin_inset Formula $e$
\end_inset

 is needed.
 Initially, the built in OpenCL function was used to calculate this.
 This function is defined by the OpenCL standard to have a specific accuracy,
 which is constant on any hardware.
 The implementation of this on the hardware in use proved to use a large
 number of General Purpose Registers (GPRs), imposing a limit on the number
 of concurrent kernel instances that could run and limiting the speed of
 the code.
\end_layout

\begin_layout Standard

\lang british
The OpenCL standard also provides for a set of so-called 'native' functions,
 are produced specifically for the hardware in use, and which are often
 more efficient than the general implementation (for example, it sometimes
 maps to a single instruction that performs the function).
 However, the accuracy of the function is implementation specific, and so
 could change from computer to computer 
\begin_inset CommandInset citation
LatexCommand cite
key "openCl11Spec"

\end_inset

.
 In this case, the native exponential function utilitises far fewer GPRs,
 removing the resource pressure previously experienced.
\end_layout

\begin_layout Standard

\lang british
Additionally, the OpenCL specification provides geometric functions such
 as vector distance and vector length to complement it's vector data types.
 These have been used as far as possible, as they can also allow the compiler
 to perform hardware specific optimisations (and again they can sometimes
 map directly to individual instructions on the hardware.
\begin_inset CommandInset citation
LatexCommand cite
key "openCl11Spec"

\end_inset


\end_layout

\begin_layout Standard

\lang british
TODO : discuss any other optimisations
\end_layout

\begin_layout Section

\lang british
Software Produced
\end_layout

\begin_layout Standard

\lang british
Two peices of software have been produced:
\end_layout

\begin_layout Itemize

\lang british
The game playing strategy file
\end_layout

\begin_layout Itemize

\lang british
The field renderer
\end_layout

\begin_layout Standard

\lang british
Only the strategy file is required to play the game, as the field renderer
 is only used to debug the potential fields.
\end_layout

\begin_layout Subsection

\lang british
Strategy File
\end_layout

\begin_layout Standard

\lang british
The strategy file is a standard Microsoft Windows DLL file which implements
 three functions defined by the simulator:
\end_layout

\begin_layout Itemize

\lang british
Create - Performs the initial setup for the strategy
\end_layout

\begin_layout Itemize

\lang british
Strategy - Called on every simulator cycle to control the robots
\end_layout

\begin_layout Itemize

\lang british
Destroy - Intended to perform the clean-up required for the strategy.
 This does not appear to be called by the simulator at this time, and so
 has been left as an empty function.
\end_layout

\begin_layout Standard

\lang british
TODO : Discuss final strategy implementation
\end_layout

\begin_layout Subsection

\lang british
Field Renderer
\end_layout

\begin_layout Standard

\lang british
TODO : tie up descriptions to function names
\end_layout

\begin_layout Standard

\lang british
The field renderer provides a near realtime view of the potential field
 and the field gradients at run time to allow easier debugging of the field
 calculations.
 The program is implemented using the MS .Net Framework and the Windows Presentat
ion Foundation.
 The OpenCL code is then executed using the Cloo library, which allows the
 program's managed code to access the unmanaged functions required to use
 OpenCL.
\end_layout

\begin_layout Standard

\lang british
The program receives a status from the simulator using a named pipe for
 which it acts as the server.
 The binary data received is intepretted into a structure to match the one
 used in the strategy file, and is stored as the latest environment.
 This occurs at the end of every simulator cycle, and is run in a seperate
 execution thread to the rest of the program.
 This allows the simulator to continue after transmission is complete without
 waiting for the renderer to work with the environment.
 Every time the status report is received, it triggers a rendering cycle,
 unless a rendering cycle is already underway.
 If a report arrives while a rendering cycle is unfinished, it is discarded.
 This ensures that the rendered images are as up to date as possible.
\end_layout

\begin_layout Standard

\lang british
The rendering process is also executed in it's own thread, ensuring that
 it does not interfere with the user interface.
 If this was not done, the program would to be unresponsive and the rendered
 images would never be displayed to the user.
 The process creates a copy of the latest status report, which ensures that
 the process is not effected by the concurrently running communication with
 the simulator.
 The code then performs the same process as the strategy file, using the
 OpenCL field calculation code (this time executed on the GPU) to calculate
 every data point in the field.
 Further OpenCL code is then used to calculate the magnitude of the gradient
 across the entire field, and more is used to transform both sets of data
 into grayscale bitmaps.
 The produced bitmaps are then passed to the user interface thread, which
 then displays the images to the user.
\end_layout

\begin_layout Section

\lang british
Discussion
\end_layout

\begin_layout Section

\lang british
Future Work
\end_layout

\begin_layout Standard
\start_of_appendix

\lang british
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section

\lang british
Code Listings 
\begin_inset CommandInset label
LatexCommand label
name "sec:Code-Listings"

\end_inset


\end_layout

\begin_layout Subsection

\lang british
OpenCL Kernels
\begin_inset CommandInset label
LatexCommand label
name "sub:OpenCL-Kernels"

\end_inset


\end_layout

\begin_layout Subsection

\lang british
Intercept Strategy File
\end_layout

\begin_layout Standard

\lang british
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard

\lang british
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "References/references"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
